{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst fsScandir = require(\"@nodelib/fs.scandir\");\n\nconst fastq = require(\"fastq\");\n\nconst common = require(\"./common\");\n\nconst reader_1 = require(\"./reader\");\n\nclass AsyncReader extends reader_1.default {\n  constructor(_root, _settings) {\n    super(_root, _settings);\n    this._settings = _settings;\n    this._scandir = fsScandir.scandir;\n    this._emitter = new events_1.EventEmitter();\n    this._queue = fastq(this._worker.bind(this), this._settings.concurrency);\n    this._isFatalError = false;\n    this._isDestroyed = false;\n\n    this._queue.drain = () => {\n      if (!this._isFatalError) {\n        this._emitter.emit('end');\n      }\n    };\n  }\n\n  read() {\n    this._isFatalError = false;\n    this._isDestroyed = false;\n    setImmediate(() => {\n      this._pushToQueue(this._root, this._settings.basePath);\n    });\n    return this._emitter;\n  }\n\n  get isDestroyed() {\n    return this._isDestroyed;\n  }\n\n  destroy() {\n    if (this._isDestroyed) {\n      throw new Error('The reader is already destroyed');\n    }\n\n    this._isDestroyed = true;\n\n    this._queue.killAndDrain();\n  }\n\n  onEntry(callback) {\n    this._emitter.on('entry', callback);\n  }\n\n  onError(callback) {\n    this._emitter.once('error', callback);\n  }\n\n  onEnd(callback) {\n    this._emitter.once('end', callback);\n  }\n\n  _pushToQueue(directory, base) {\n    const queueItem = {\n      directory,\n      base\n    };\n\n    this._queue.push(queueItem, error => {\n      if (error !== null) {\n        this._handleError(error);\n      }\n    });\n  }\n\n  _worker(item, done) {\n    this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {\n      if (error !== null) {\n        done(error, undefined);\n        return;\n      }\n\n      for (const entry of entries) {\n        this._handleEntry(entry, item.base);\n      }\n\n      done(null, undefined);\n    });\n  }\n\n  _handleError(error) {\n    if (this._isDestroyed || !common.isFatalError(this._settings, error)) {\n      return;\n    }\n\n    this._isFatalError = true;\n    this._isDestroyed = true;\n\n    this._emitter.emit('error', error);\n  }\n\n  _handleEntry(entry, base) {\n    if (this._isDestroyed || this._isFatalError) {\n      return;\n    }\n\n    const fullpath = entry.path;\n\n    if (base !== undefined) {\n      entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);\n    }\n\n    if (common.isAppliedFilter(this._settings.entryFilter, entry)) {\n      this._emitEntry(entry);\n    }\n\n    if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {\n      this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);\n    }\n  }\n\n  _emitEntry(entry) {\n    this._emitter.emit('entry', entry);\n  }\n\n}\n\nexports.default = AsyncReader;","map":{"version":3,"sources":["C:/Users/DELL/Desktop/Trainig/MERN-stack/client/node_modules/@nodelib/fs.walk/out/readers/async.js"],"names":["Object","defineProperty","exports","value","events_1","require","fsScandir","fastq","common","reader_1","AsyncReader","default","constructor","_root","_settings","_scandir","scandir","_emitter","EventEmitter","_queue","_worker","bind","concurrency","_isFatalError","_isDestroyed","drain","emit","read","setImmediate","_pushToQueue","basePath","isDestroyed","destroy","Error","killAndDrain","onEntry","callback","on","onError","once","onEnd","directory","base","queueItem","push","error","_handleError","item","done","fsScandirSettings","entries","undefined","entry","_handleEntry","isFatalError","fullpath","path","joinPathSegments","name","pathSegmentSeparator","isAppliedFilter","entryFilter","_emitEntry","dirent","isDirectory","deepFilter"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAD,CAAxB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,qBAAD,CAAzB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMK,WAAN,SAA0BD,QAAQ,CAACE,OAAnC,CAA2C;AACvCC,EAAAA,WAAW,CAACC,KAAD,EAAQC,SAAR,EAAmB;AAC1B,UAAMD,KAAN,EAAaC,SAAb;AACA,SAAKA,SAAL,GAAiBA,SAAjB;AACA,SAAKC,QAAL,GAAgBT,SAAS,CAACU,OAA1B;AACA,SAAKC,QAAL,GAAgB,IAAIb,QAAQ,CAACc,YAAb,EAAhB;AACA,SAAKC,MAAL,GAAcZ,KAAK,CAAC,KAAKa,OAAL,CAAaC,IAAb,CAAkB,IAAlB,CAAD,EAA0B,KAAKP,SAAL,CAAeQ,WAAzC,CAAnB;AACA,SAAKC,aAAL,GAAqB,KAArB;AACA,SAAKC,YAAL,GAAoB,KAApB;;AACA,SAAKL,MAAL,CAAYM,KAAZ,GAAoB,MAAM;AACtB,UAAI,CAAC,KAAKF,aAAV,EAAyB;AACrB,aAAKN,QAAL,CAAcS,IAAd,CAAmB,KAAnB;AACH;AACJ,KAJD;AAKH;;AACDC,EAAAA,IAAI,GAAG;AACH,SAAKJ,aAAL,GAAqB,KAArB;AACA,SAAKC,YAAL,GAAoB,KAApB;AACAI,IAAAA,YAAY,CAAC,MAAM;AACf,WAAKC,YAAL,CAAkB,KAAKhB,KAAvB,EAA8B,KAAKC,SAAL,CAAegB,QAA7C;AACH,KAFW,CAAZ;AAGA,WAAO,KAAKb,QAAZ;AACH;;AACc,MAAXc,WAAW,GAAG;AACd,WAAO,KAAKP,YAAZ;AACH;;AACDQ,EAAAA,OAAO,GAAG;AACN,QAAI,KAAKR,YAAT,EAAuB;AACnB,YAAM,IAAIS,KAAJ,CAAU,iCAAV,CAAN;AACH;;AACD,SAAKT,YAAL,GAAoB,IAApB;;AACA,SAAKL,MAAL,CAAYe,YAAZ;AACH;;AACDC,EAAAA,OAAO,CAACC,QAAD,EAAW;AACd,SAAKnB,QAAL,CAAcoB,EAAd,CAAiB,OAAjB,EAA0BD,QAA1B;AACH;;AACDE,EAAAA,OAAO,CAACF,QAAD,EAAW;AACd,SAAKnB,QAAL,CAAcsB,IAAd,CAAmB,OAAnB,EAA4BH,QAA5B;AACH;;AACDI,EAAAA,KAAK,CAACJ,QAAD,EAAW;AACZ,SAAKnB,QAAL,CAAcsB,IAAd,CAAmB,KAAnB,EAA0BH,QAA1B;AACH;;AACDP,EAAAA,YAAY,CAACY,SAAD,EAAYC,IAAZ,EAAkB;AAC1B,UAAMC,SAAS,GAAG;AAAEF,MAAAA,SAAF;AAAaC,MAAAA;AAAb,KAAlB;;AACA,SAAKvB,MAAL,CAAYyB,IAAZ,CAAiBD,SAAjB,EAA6BE,KAAD,IAAW;AACnC,UAAIA,KAAK,KAAK,IAAd,EAAoB;AAChB,aAAKC,YAAL,CAAkBD,KAAlB;AACH;AACJ,KAJD;AAKH;;AACDzB,EAAAA,OAAO,CAAC2B,IAAD,EAAOC,IAAP,EAAa;AAChB,SAAKjC,QAAL,CAAcgC,IAAI,CAACN,SAAnB,EAA8B,KAAK3B,SAAL,CAAemC,iBAA7C,EAAgE,CAACJ,KAAD,EAAQK,OAAR,KAAoB;AAChF,UAAIL,KAAK,KAAK,IAAd,EAAoB;AAChBG,QAAAA,IAAI,CAACH,KAAD,EAAQM,SAAR,CAAJ;AACA;AACH;;AACD,WAAK,MAAMC,KAAX,IAAoBF,OAApB,EAA6B;AACzB,aAAKG,YAAL,CAAkBD,KAAlB,EAAyBL,IAAI,CAACL,IAA9B;AACH;;AACDM,MAAAA,IAAI,CAAC,IAAD,EAAOG,SAAP,CAAJ;AACH,KATD;AAUH;;AACDL,EAAAA,YAAY,CAACD,KAAD,EAAQ;AAChB,QAAI,KAAKrB,YAAL,IAAqB,CAAChB,MAAM,CAAC8C,YAAP,CAAoB,KAAKxC,SAAzB,EAAoC+B,KAApC,CAA1B,EAAsE;AAClE;AACH;;AACD,SAAKtB,aAAL,GAAqB,IAArB;AACA,SAAKC,YAAL,GAAoB,IAApB;;AACA,SAAKP,QAAL,CAAcS,IAAd,CAAmB,OAAnB,EAA4BmB,KAA5B;AACH;;AACDQ,EAAAA,YAAY,CAACD,KAAD,EAAQV,IAAR,EAAc;AACtB,QAAI,KAAKlB,YAAL,IAAqB,KAAKD,aAA9B,EAA6C;AACzC;AACH;;AACD,UAAMgC,QAAQ,GAAGH,KAAK,CAACI,IAAvB;;AACA,QAAId,IAAI,KAAKS,SAAb,EAAwB;AACpBC,MAAAA,KAAK,CAACI,IAAN,GAAahD,MAAM,CAACiD,gBAAP,CAAwBf,IAAxB,EAA8BU,KAAK,CAACM,IAApC,EAA0C,KAAK5C,SAAL,CAAe6C,oBAAzD,CAAb;AACH;;AACD,QAAInD,MAAM,CAACoD,eAAP,CAAuB,KAAK9C,SAAL,CAAe+C,WAAtC,EAAmDT,KAAnD,CAAJ,EAA+D;AAC3D,WAAKU,UAAL,CAAgBV,KAAhB;AACH;;AACD,QAAIA,KAAK,CAACW,MAAN,CAAaC,WAAb,MAA8BxD,MAAM,CAACoD,eAAP,CAAuB,KAAK9C,SAAL,CAAemD,UAAtC,EAAkDb,KAAlD,CAAlC,EAA4F;AACxF,WAAKvB,YAAL,CAAkB0B,QAAlB,EAA4Bb,IAAI,KAAKS,SAAT,GAAqBA,SAArB,GAAiCC,KAAK,CAACI,IAAnE;AACH;AACJ;;AACDM,EAAAA,UAAU,CAACV,KAAD,EAAQ;AACd,SAAKnC,QAAL,CAAcS,IAAd,CAAmB,OAAnB,EAA4B0B,KAA5B;AACH;;AAvFsC;;AAyF3ClD,OAAO,CAACS,OAAR,GAAkBD,WAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst fsScandir = require(\"@nodelib/fs.scandir\");\nconst fastq = require(\"fastq\");\nconst common = require(\"./common\");\nconst reader_1 = require(\"./reader\");\nclass AsyncReader extends reader_1.default {\n    constructor(_root, _settings) {\n        super(_root, _settings);\n        this._settings = _settings;\n        this._scandir = fsScandir.scandir;\n        this._emitter = new events_1.EventEmitter();\n        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);\n        this._isFatalError = false;\n        this._isDestroyed = false;\n        this._queue.drain = () => {\n            if (!this._isFatalError) {\n                this._emitter.emit('end');\n            }\n        };\n    }\n    read() {\n        this._isFatalError = false;\n        this._isDestroyed = false;\n        setImmediate(() => {\n            this._pushToQueue(this._root, this._settings.basePath);\n        });\n        return this._emitter;\n    }\n    get isDestroyed() {\n        return this._isDestroyed;\n    }\n    destroy() {\n        if (this._isDestroyed) {\n            throw new Error('The reader is already destroyed');\n        }\n        this._isDestroyed = true;\n        this._queue.killAndDrain();\n    }\n    onEntry(callback) {\n        this._emitter.on('entry', callback);\n    }\n    onError(callback) {\n        this._emitter.once('error', callback);\n    }\n    onEnd(callback) {\n        this._emitter.once('end', callback);\n    }\n    _pushToQueue(directory, base) {\n        const queueItem = { directory, base };\n        this._queue.push(queueItem, (error) => {\n            if (error !== null) {\n                this._handleError(error);\n            }\n        });\n    }\n    _worker(item, done) {\n        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {\n            if (error !== null) {\n                done(error, undefined);\n                return;\n            }\n            for (const entry of entries) {\n                this._handleEntry(entry, item.base);\n            }\n            done(null, undefined);\n        });\n    }\n    _handleError(error) {\n        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {\n            return;\n        }\n        this._isFatalError = true;\n        this._isDestroyed = true;\n        this._emitter.emit('error', error);\n    }\n    _handleEntry(entry, base) {\n        if (this._isDestroyed || this._isFatalError) {\n            return;\n        }\n        const fullpath = entry.path;\n        if (base !== undefined) {\n            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);\n        }\n        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {\n            this._emitEntry(entry);\n        }\n        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {\n            this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);\n        }\n    }\n    _emitEntry(entry) {\n        this._emitter.emit('entry', entry);\n    }\n}\nexports.default = AsyncReader;\n"]},"metadata":{},"sourceType":"script"}